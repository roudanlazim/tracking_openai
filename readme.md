1. Install dependencies in requirements
2. Set enviroment 
4. activate environment - env\Scripts\activate
5. Run the script - 

Ensure all of the json, csv and other files are present for it to work. 
Ensure the api key is correct. 

# AI Status Testing Project

## Overview
This project automates the testing and training of AI-generated shipment statuses using OpenAI's API. It processes shipping journeys (**AI Stories**) and predicts the most appropriate final status based on predefined rules, resolving scans, and structured training data.

---
You only really need the json for status elemments and the ai_stories csv- this is what you are testing on. 
The results is obviousdly generated by the script 

## File Structure

### **Data Files**
- **`data/scan_groups.json`** ‚Üí Defines action-required scans and their impact.
- **`data/status_elements.json`** ‚Üí List of valid final statuses.
- **`data/resolving_scans.json`** ‚Üí Defines scans that resolve action-based issues (e.g., customs release, arrival at depot).
- **`data/ai_stories.csv`** ‚Üí Input CSV containing AI stories and expected results.
- **`data/results.csv`** ‚Üí Output CSV with predicted statuses.

### **Scripts & Their Functions**

#### **1. `generate_data.py`** (Prepares datasets for training)
- Splits AI Stories into **training** and **test** datasets.
- Creates **backups** of previous training data before overwriting.

#### **2. `prepare_data.py`** (Cleans and formats data for fine-tuning)
- **Ignores irrelevant scans** (`Shipment Manifested`, `Billing Information Received`) unless they are the only scans.
- **Groups action-required statuses** together (e.g., customs holds, address issues).
- **Ensures resolving scans** (e.g., `Out for Delivery`, `Arrival at Depot`) correctly update the final status.
- **Flags uncertain cases** for manual review.
- Converts the cleaned dataset into a **JSONL format** for OpenAI fine-tuning.

#### **3. `fine_tune.py`** (Fine-tunes the OpenAI model)
- Uploads structured JSONL training data to OpenAI.
- Triggers fine-tuning on a selected model (e.g., `gpt-3.5-turbo`).
- Logs fine-tuning details and generates model IDs for future use.

#### **4. `predict.py`** (Predicts shipment status from AI Stories)
- Uses the fine-tuned model to predict final statuses.
- **Post-processing ensures**:
  - **Customs holds remain final** until a resolving scan appears.
  - **Address issues persist** unless resolved.
  - **Delivered statuses** are correctly identified.
  - **Manual review is flagged for ambiguous cases.**

#### **5. `ai_status_testing.py`** (Tests model accuracy & logs results)
- Loads test data and compares **expected vs. predicted statuses**.
- Tracks token usage for OpenAI API efficiency.
- Generates output reports detailing:
  - **Correct predictions**
  - **Incorrect predictions**
  - **Flagged cases requiring review**

---

## **Training Data Processing & Rules**

### **Final Status Selection Rules**
#### **1. Prioritize Delivered Statuses**
- If `"Delivered"` or a variation (e.g., `"Delivered to a safe place"`, `"Driver release"`) exists ‚Üí **use it as the final status.**
- If multiple `"Delivered"` statuses appear, **select the most specific one.**

#### **2. Handling Customs Holds & Address Issues**
- If `"Held in Customs"` or `"Address Issue"` appears:
  - It remains the final status **unless a resolving scan appears.**
  - Resolving scans include:
    - `Released by Customs`
    - `Arrival at Delivery Depot`
    - `Out for Delivery`
  - If no resolving scan appears, **customs/hold status remains final.**

#### **3. Ignoring Shipment Manifested & Billing Info**
- `"Shipment Manifested"` and `"Billing Information Received"` **are ignored** unless they are the **only** scans.
- If other scans exist, **we use the most relevant one instead.**

#### **4. Manual Review for Ambiguous Cases**
- If an AI Story has **conflicting scans** (e.g., `"Warehouse Scan"` + `"In Transit"` with no clear resolution), it is **flagged for manual review** instead of forcing a guess.
- The model will output **`FLAGGED: Manual Review Required`** for such cases.

---

## **Example Behavior of the Updated Model**

| **AI Story** | **Final Status** |
|-------------|----------------|
| **At first it was Out for Delivery, then it was Delivered.** | **Delivered** |
| **At first it was Out for Delivery, then it was Delivered to a safe place.** | **Delivered to a safe place** |
| **At first it was Shipment manifested, then it was Held in Customs, then it was Warehouse Scan, then it was In Transit.** | **Held in Customs** (No resolving scan) |
| **At first it was Held in Customs, then it was In Transit, then it was Released by Customs, then it was Arrival at Delivery Depot.** | **Arrival at Delivery Depot** (Resolved) |
| **At first it was Address Issue - Additional Information Required, then it was Warehouse Scan, then it was In Transit.** | **Address Issue - Additional Information Required** (No resolving scan) |
| **At first it was Address Issue - Additional Information Required, then it was Out for Delivery.** | **Out for Delivery** (Resolved) |
| **At first it was Shipment Manifested, then it was Warehouse Scan, then it was Internal Scan.** | **FLAGGED: Manual Review Required** (Uncertain case) |

---

## **Fine-Tuning Workflow**
1Ô∏è‚É£ **Generate Training & Test Data** (`generate_data.py`)
2Ô∏è‚É£ **Preprocess & Structure Data** (`prepare_data.py`)
3Ô∏è‚É£ **Fine-Tune OpenAI Model** (`fine_tune.py`)
4Ô∏è‚É£ **Predict Shipment Statuses** (`predict.py`)
5Ô∏è‚É£ **Test Model Accuracy & Flag Issues** (`ai_status_testing.py`)

---

## **Next Steps**
- üöÄ **Retrain the model with new structured datasets.**
- üîé **Review flagged cases manually for refinement.**
- üìà **Monitor prediction accuracy and improve resolving scans logic.**
- üõ† **Optimize API efficiency by reducing token usage in predictions.**

This README will be updated as the project evolves. - Use most up to data versions pf pandas and numpty

import pandas as pd
import json
import os
import logging
import shutil
from utils import load_json
from datetime import datetime

# Define ignored scans (this is extra - ignore)
IGNORED_SCANS = {"Shipment Manifested", "Billing Information Received", "Internal Scan"}

# Define resolving scans for action-required cases (this is extra - ignore)
RESOLVING_SCANS = {"Released by Customs", "Arrival at Delivery Depot", "Arrival at Hub", "Out for Delivery"}

# Define all variations of Delivered (this is extra - ignore)
DELIVERED_VARIANTS = {
    "Delivered",
    "Driver release - Delivered to a safe place",
    "Delivered to postbox",
    "Delivered to greenhouse",
    "Delivered to outbuilding",
    "Shipment delivered. Possible damage"
}

# Define action-required statuses (this is extra - ignore)
ACTION_REQUIRED_STATUSES = {
    "Held in Customs",
    "Awaiting Release from Customs",
    "Customs Clearance in Progress",
    "Held Awaiting Tax Payment by Receiver",
    "Address Issue - Additional Information Required",
    "Delivery Attempted - Address Problem",
    "Package on Hold for Delivery"
}

def determine_final_status(ai_story, valid_statuses):
    """
    Determine the correct final status:
    - Prioritize delivered status variations if they exist.
    - If an action-required status exists, it remains final unless a resolving scan appears.
    - Ignore 'Shipment Manifested' and 'Billing Information Received' if a valid scan exists.
    - If uncertainty exists, flag for manual review.
    """
    scans = {scan.strip() for scan in ai_story.split(", then it was ")}

    # Prioritize Delivered Variants
    delivered_scans = scans & DELIVERED_VARIANTS
    if delivered_scans:
        return sorted(delivered_scans, key=lambda x: valid_statuses.index(x) if x in valid_statuses else float('inf'))[-1]

    # Handle Action-Required Statuses
    action_scans = scans & ACTION_REQUIRED_STATUSES
    if action_scans:
        if not scans & RESOLVING_SCANS:  # If no resolving scan, return the action-required status
            return sorted(action_scans, key=lambda x: valid_statuses.index(x) if x in valid_statuses else float('inf'))[-1]

    # Remove ignored scans if other valid scans exist
    valid_scans = scans - IGNORED_SCANS
    if valid_scans:
        sorted_valid_scans = sorted(valid_scans, key=lambda x: valid_statuses.index(x) if x in valid_statuses else float('inf'))
        return sorted_valid_scans[-1]

    # If the status is unclear, flag it for manual review
    return "FLAGGED: Manual Review Required"

# Logging setup
LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)
log_filename = os.path.join(LOG_DIR, f"prepare_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
logging.basicConfig(
    filename=log_filename,
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

def backup_old_jsonl(output_jsonl):
    """Backup previous JSONL training file before overwriting."""
    if os.path.exists(output_jsonl):
        shutil.move(output_jsonl, output_jsonl.replace(".jsonl", "_backup.jsonl"))
        logging.info(f"üîÑ Previous training JSONL file backed up: {output_jsonl}_backup.jsonl")

def prepare_training_data(input_csv, output_jsonl, status_elements_file):
    """Convert training CSV into OpenAI fine-tuning JSONL format."""
    try:
        logging.info(f"üì• Loading training data: {input_csv}")
        df = pd.read_csv(input_csv)
        valid_statuses = load_json(status_elements_file)
        if df.empty:
            logging.error("‚ùå Error: Training CSV file is empty.")
            print("‚ùå Error: Training CSV file is empty.")
            return
        
        backup_old_jsonl(output_jsonl)
        processed_count = 0
        skipped_count = 0
        
        with open(output_jsonl, "w") as f:
            for _, row in df.iterrows():
                ai_story = str(row["AiStory"]).strip()
                correct_status = str(row["Status"]).strip()

                # Skip rows with missing AiStory or Status
                if not ai_story or not correct_status:
                    logging.warning(f"‚ö†Ô∏è Skipping row due to missing data: {row}")
                    skipped_count += 1
                    continue

                # Skip invalid statuses
                if correct_status not in valid_statuses:
                    logging.warning(f"‚ö†Ô∏è Skipping row with invalid status: {correct_status}")
                    skipped_count += 1
                    continue

                entry = {"messages": [
                    {"role": "user", "content": ai_story},
                    {"role": "assistant", "content": correct_status}
                ]}
                f.write(json.dumps(entry) + "\n")
                processed_count += 1

        logging.info(f"‚úÖ Training data formatted and saved to {output_jsonl}")
        logging.info(f"üìä Summary: {processed_count} entries processed, {skipped_count} skipped")
        print(f"‚úÖ Training data saved to {output_jsonl} ({processed_count} valid entries, {skipped_count} skipped)")

    except FileNotFoundError as e:
        logging.error(f"‚ùå Error: File not found - {e}")
        print(f"‚ùå Error: File not found - {e}")
    except pd.errors.ParserError as e:
        logging.error(f"‚ùå Error: Parsing CSV failed - {e}")
        print(f"‚ùå Error: Parsing CSV failed - {e}")
    except Exception as e:
        logging.error(f"‚ùå Unexpected error: {e}")
        print(f"‚ùå Unexpected error: {e}")

if __name__ == "__main__":
    train_csv = "data/train.csv"
    training_jsonl = "data/training_data.jsonl"
    status_elements_file = "data/status_elements.json"
    logging.info("üöÄ Starting JSONL Preparation...")
    prepare_training_data(train_csv, training_jsonl, status_elements_file)
    logging.info("üéØ JSONL Preparation Completed!")



1. Ensuring "Delivered" is Always Final (Unless Overridden)
If any variation of "Delivered" appears in the AI story, the final status is "Delivered" unless explicitly overridden.
Recognized "Delivered" variations:
Delivered
Delivered to postbox
Driver release - Delivered to a safe place
Delivered to greenhouse
Delivered to outbuilding
Shipment delivered. Possible damage
Delivered to neighbor
Delivered to 3rd party
Any other delivered-type statuses not present in status_elements.json are generalized to "Delivered".
2. Handling "In Transit" Status Correctly
"In Transit" should only be assigned if there are scans showing movement, such as:
In Transit
Arrived at Export Hub
Customs Cleared
If none of these movement scans are present, it should not be assigned as "In Transit".
3. Correcting "Shipment Manifested" & "Billing Information Received"
If the only scans are:
Billing Information Received
Shipment Manifested
The correct final status is "Shipment Manifested" since there is no sign of movement.
4. Recognizing "Shipment Ready for Collection"
If the AI story contains:
Shipment ready for collection
Pick-up point
The correct status is now "Shipment ready for collection from pick-up point" instead of mistakenly assigning In Transit or Out for Delivery.
5. Prioritizing Specific "Collection Failed" Statuses
Instead of just assigning "Collection Failed", we now assign:
Collection failed - Parcel not ready
Collection failed - Shipper not available
Collection failed - Unable to gain access
This ensures that more specific failure reasons are applied when possible.
6. The Typical Shipment Journey (Irrespective of Scan Order)
To ensure the model correctly understands shipment progress, we applied the logic that:

Shipment Manifested
Billing Information Received
Shipment Collected
In Transit
Arrived at Export Hub
Entered Customs
Customs Cleared
In Transit (again)
Out for Delivery
Delivered (Final Status)
The logic does not depend on the exact order but rather on the presence of key scan events.
If a shipment has not reached a later stage, it retains the most relevant previous status.


Stage 1: Status Element Recognition (Current Phase)

Objective: Ensure the model knows all status elements.
Dataset: AI stories where each status element is explicitly stated.
Size Recommendation: At least 5-10 variations per status element (~1,500‚Äì3,000 examples total).
Outcome: The model will understand and predict status elements correctly.

Stage 2: Learning Typical Shipment Journeys
Objective: Teach the model the progression of shipments.
Dataset: AI stories that follow realistic shipment journeys, including:
Common transitions (Manifested ‚Üí Collected ‚Üí In Transit ‚Üí Delivered).
Delays, customs holds, address issues, failed deliveries, etc.
Dataset Size: 5,000+ examples to capture enough variance.
Outcome: The model understands how shipments progress over time.

Stage 3: Edge Cases & Complex Scenarios
Objective: Improve handling of nuances and rare cases.
Dataset:
Stories with misdeliveries, label issues, package damages, etc.
Scenarios with incorrect status assignments (for adversarial learning).
Size: 3,000+ additional examples focusing on edge cases.
Outcome: The model can handle real-world variability and resolve conflicts in status determination.

-------------------

# AI Status Classification - Tiered Filtering & Training Strategy

## **Objective**
To achieve **999 accuracy** in shipment status classification by implementing a **tiered filtering approach**, **staged AI training**, and **post-prediction validation**.

## **1Ô∏è‚É£ Pre-Processing: AI Story Filtering (Before AI Querying)**
Before querying the AI model, we implement **logical filtering rules** to remove unnecessary data and pre-classify certain statuses.

### **Filtering Steps:**
- **Auto-Assign Final Statuses**:
  - If *Delivered* is present ‚Üí **Auto-mark as final status** (No AI Query Required).
  - If *Returned to Sender* is present ‚Üí **Auto-mark**.
- **Problem-Resolution Handling**:
  - If *Customs Delay* occurs but later *Released by Customs* appears ‚Üí **Ignore the delay scan** and consider the resolution.
  - If *Request to Reschedule Delivery* is followed by *Out for Delivery* ‚Üí **Ignore the request**.
- **Ignore Non-Impactful Scans**:
  - *Billing information received* ‚Üí Ignore unless it's the only scan.
  - *Shipment manifested* ‚Üí Ignore unless it appears only with other ignorable scans.
  - *Internal scans* (e.g., *Warehouse Scan*, *Hub Arrived*) ‚Üí Ignore unless affecting movement status.

**Outcome**: The AI model receives a **cleaned and optimized AI Story** with only meaningful status elements.(this is extra - ignore)

---

## **2Ô∏è‚É£ AI Model Training Strategy (Staged Approach)**
We train the model in **stages** to ensure it **learns the correct prioritization** rather than just sequence order.

### **Training Stages:**
1. **Final Status Priority Training**:
   - AI learns to prioritize *Delivered*, *Returned to Sender*, and *Finalized Statuses*.
   - Ensures *Delivered* is **always** predicted when present.
2. **Resolution Overwrites Problems**:
   - AI learns that *Released by Customs* **overrides** *Customs Delay*.
   - AI learns that *Out for Delivery* **resolves** a failed attempt.
3. **Movement vs. Non-Movement Statuses**:
   - AI differentiates *In Transit* vs. *Warehouse Scans* (Non-Movement).
   - AI only considers **scans that indicate progression**.
4. **Edge Case Handling**:
   - AI learns **handling of ambiguous cases** (e.g., *Transferred to Third Party* vs. *Delivered*).

**Outcome**: The AI learns logical decision-making rather than just sequence patterns.

---

## **3Ô∏è‚É£ Post-Prediction Validation & Auto-Correction**
After the AI predicts a status, we validate and auto-correct it:

### **Post-Processing Steps:**
- **If AI Prediction is NOT in the learned list** ‚Üí Use **string similarity matching** to auto-correct.
- **If multiple possible statuses exist** ‚Üí Choose the highest priority:
  - *Delivered* > *Out for Delivery* > *In Transit*
  - *Released by Customs* > *Customs Delay*
  - *Handover to Broker* > *Pending Customs Clearance*
- **Fallback Handling**:
  - If AI outputs an *unrecognized* status ‚Üí Flag for review.
  - If AI prediction conflicts with a known rule ‚Üí Auto-correct based on resolution logic.

**Outcome**: Any AI errors are caught and corrected **before** being logged in results.

---

## **Implementation Plan**

### **Phase 1: Implement Filtering & Pre-Processing**
Apply **AI Story Filtering Rules** to remove unnecessary statuses **before** querying the AI model.
Auto-assign *Delivered* and other final statuses **without AI queries**.

### **Phase 2: Fine-Tune AI Model in Stages**
Train AI using **priority logic** to ensure correct classification.
Ensure AI **overwrites problem statuses with their resolution**.
Optimize AI to focus on **movement-based statuses** rather than sequential order.

### **Phase 3: Post-Prediction Validation**
Implement **auto-correction and fallback rules**.
Log AI prediction confidence and **flag uncertain predictions**.

---

## **Final Goal**
- **Achieve 999 accuracy** for critical statuses (*Delivered*, *Returned to Sender*).
- **Reduce AI misclassifications** by filtering unimportant scans.
- **Ensure logical handling** of conflicting shipment statuses.

Problem - Hollucinations - These are going to be very hard to prvent using a general large language model as the base. 